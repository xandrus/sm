#! /usr/bin/env python2

import configparser
import os
import re
import signal
import subprocess

MAY_PROMOT_RE = re.compile(
    '(?:exists|change) resource name:((?:\\w|-)+) '
    '(?:\\w+\\:\\w+ )*may_promote:(yes|no) promotion_score:(\\d+)'
)
PEER_ROLE_RE = re.compile(
    '(?:exists|change) connection name:((?:\\w|-)+) peer-node-id:(?:\\d+) '
    'conn-name:(\\w+) (?:\\w+\\:\\w+ )*role:(Primary|Secondary|Unknown)'
)
HAVE_QUORUM_RE = re.compile(
    '(?:exists|change) device name:((?:\\w|-)+) '
    '(?:\\w+\\:\\w+ )*quorum:(yes|no)'
)


class SigHupException(Exception):
    pass


def sig_handler(sig, frame):
    raise SigHupException(
        'Received signal ' + str(sig) +
        ' on line ' + str(frame.f_lineno) +
        ' in ' + frame.f_code.co_filename
    )


def call_systemd(operation, service):
    verbose = operation in ('start', 'stop')
    if verbose:
        print('Trying to %s %s' % (operation, service))
    r = os.system('systemctl %s %s' % (operation, service))
    if verbose:
        print('%s for %s %s' % (
            'success' if r == 0 else 'failure', operation, service
        ))
    return r == 0


def show_status(services, status):
    print('status:')
    for systemd_unit in services:
        call_systemd('status', systemd_unit)
    for res_name in status:
        print('%s is %s' % (res_name, status[res_name]))


def clean_up(services):
    print('exiting:')
    for systemd_unit in reversed(services):
        call_systemd('stop', systemd_unit)


def process(events2, resources, services, status):
    line = events2.stdout.readline()
    if not line:
        return

    m = MAY_PROMOT_RE.match(line)
    if m:
        res_name, may_promote, promotion_score = m.groups()
        if res_name in resources and may_promote == 'yes':
            systemd_units_str = resources[res_name]['systemd-units']
            systemd_units = [x.strip() for x in systemd_units_str.split(',')]
            to_start = [x for x in systemd_units if x not in services]
            for systemd_unit in to_start:
                r = call_systemd('start', systemd_unit)
                if r:
                    services.append(systemd_unit)
                else:
                    break
    m = PEER_ROLE_RE.match(line)
    if m:
        res_name, conn_name, role = m.groups()
        if res_name in status:
            status[res_name][conn_name] = role
    m = HAVE_QUORUM_RE.match(line)
    if m:
        res_name, have_quorum = m.groups()
        if res_name in resources and have_quorum == 'no':
            systemd_units_str = resources[res_name]['systemd-units']
            systemd_units = [x.strip() for x in systemd_units_str.split(',')]
            to_stop = [x for x in systemd_units if x in services]
            if to_stop:
                print('Lost quorum on %s' % (res_name))
            for systemd_unit in reversed(to_stop):
                r = call_systemd('stop', systemd_unit)
                if r:
                    services.remove(systemd_unit)


def main():
    services = []
    status = dict()
    config = configparser.ConfigParser()
    config.read('/etc/minidrbdcluster.ini')
    resources = config._sections
    if not resources:
        raise Exception(
            'No resources to watch, maybe /etc/minidrbdcluster.ini missing'
        )
    print('Managing DRBD resources: %s' % (' '.join(resources)))
    for res_name in resources:
        status[res_name] = dict()
        # TODO: USE drbadm to find path.
        os.system('lvchange -ay /dev/linstor_group/xcp-persistent-database_00000')
        os.system('drbdadm adjust %s' % (res_name))

    signal.signal(signal.SIGHUP, sig_handler)

    print('Starting process...')
    events2 = subprocess.Popen(
        ['drbdsetup', 'events2'], stdout=subprocess.PIPE
    )
    run = True
    while run:
        try:
            process(events2, resources, services, status)
        except KeyboardInterrupt:
            run = False
        except SigHupException:
            show_status(services, status)

    clean_up(services)


if __name__ == '__main__':
    main()
